# Shared shell environment for bash and zsh
# Source this from .bashrc and .zshrc

# Ensure TERM is supported on this system, fallback if not
# This handles SSH to systems without tmux-256color terminfo (e.g., Synology NAS)
if ! infocmp "$TERM" >/dev/null 2>&1; then
  if infocmp tmux-256color >/dev/null 2>&1; then
    export TERM=tmux-256color
  elif infocmp screen-256color >/dev/null 2>&1; then
    export TERM=screen-256color
  else
    export TERM=xterm-256color
  fi
fi

# UTF-8 locale for proper Unicode/Nerd Font rendering
export LANG="${LANG:-en_US.UTF-8}"
export LC_ALL="${LC_ALL:-en_US.UTF-8}"

# Initialize Homebrew for macOS or Linux
if [ -f "/opt/homebrew/bin/brew" ]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [ -f "/home/linuxbrew/.linuxbrew/bin/brew" ]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi

# Cargo/Rust
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

# Foundry (Ethereum development)
if [ -d "$HOME/.foundry" ]; then
  export PATH="$PATH:$HOME/.foundry/bin"
fi

# Local binaries
export PATH="$PATH:$HOME/.local/bin"

# Antigravity
if [ -d "$HOME/.antigravity/antigravity/bin" ]; then
  export PATH="$HOME/.antigravity/antigravity/bin:$PATH"
fi

# Google Cloud SDK
if [ -d "$HOME/google-cloud-sdk/bin" ]; then
  export PATH="$HOME/google-cloud-sdk/bin:$PATH"
fi

# gog (Gmail CLI)
if [ -d "$HOME/gogcli/bin" ]; then
  export PATH="$HOME/gogcli/bin:$PATH"
fi

# Package manager priority: npm (NVM) → pnpm → Bun
# Listed in reverse order so Bun has highest priority in PATH

# NVM settings (provides npm - lowest priority of the three)
export NVM_DIR="$HOME/.nvm"
export NVM_COMPLETION=true
export NVM_SYMLINK_CURRENT="true"

# Load nvm (for bash; zsh uses zsh-nvm plugin)
# Only load if nvm command doesn't exist yet (avoids conflict with zsh-nvm)
if [ -s "$NVM_DIR/nvm.sh" ] && ! command -v nvm &>/dev/null; then
  . "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"
fi

# pnpm (medium priority)
if [ -d "$HOME/Library/pnpm" ]; then
  export PNPM_HOME="$HOME/Library/pnpm"
elif [ -d "$HOME/.local/share/pnpm" ]; then
  export PNPM_HOME="$HOME/.local/share/pnpm"
fi
if [ -n "$PNPM_HOME" ]; then
  case ":$PATH:" in
    *":$PNPM_HOME:"*) ;;
    *) export PATH="$PNPM_HOME:$PATH" ;;
  esac
fi

# Bun (highest priority - added last to be first in PATH)
if [ -d "$HOME/.bun/bin" ]; then
  export PATH="$HOME/.bun/bin:$PATH"
fi

# MySQL client alias (Linuxbrew)
if [ -f "/home/linuxbrew/.linuxbrew/opt/mysql-client/bin/mysql" ]; then
  alias mysql="/home/linuxbrew/.linuxbrew/opt/mysql-client/bin/mysql"
fi

# WSL environment
if [ -f /proc/version ] && grep -q "microsoft" /proc/version 2>/dev/null; then
  WINDOWS_DIR=$(wslpath -u "$(wslvar SYSTEMROOT)" 2>/dev/null)
  if [ -n "$WINDOWS_DIR" ]; then
    explorer() { "${WINDOWS_DIR}/explorer.exe" "$@"; }
    cmd() { "${WINDOWS_DIR}/system32/cmd.exe" "$@"; }
  fi
  export XDG_RUNTIME_DIR="$HOME/.xdg_runtime"
  if [ ! -d "$XDG_RUNTIME_DIR" ]; then
    mkdir -p "$XDG_RUNTIME_DIR"
    chmod 0700 "$XDG_RUNTIME_DIR"
  fi
fi

# Cross-platform SSH agent setup
keys() {
  # Detect platform
  local is_wsl=false
  local is_macos=false

  if [[ "$OSTYPE" == "darwin"* ]]; then
    is_macos=true
  elif [ -f /proc/version ] && grep -q "microsoft" /proc/version 2>/dev/null; then
    is_wsl=true
  fi

  # macOS: Use keychain integration
  if [ "$is_macos" = true ]; then
    if ! ssh-add -l &>/dev/null; then
      ssh-add --apple-load-keychain 2>/dev/null || ssh-add -K ~/.ssh/id_ed25519 2>/dev/null
    fi
    echo "SSH keys loaded from macOS keychain"
    ssh-add -l
    return 0
  fi

  # WSL2: Use keychain utility if available
  if [ "$is_wsl" = true ] && command -v keychain &>/dev/null; then
    eval "$(keychain --eval --agents ssh id_rsa 2>/dev/null)"
    echo "SSH keys loaded via keychain"
    ssh-add -l 2>/dev/null || echo "No keys loaded"
    return 0
  fi

  # Linux: Try systemd user ssh-agent first, fallback to keychain or manual agent
  if [ "$is_wsl" = false ] && [ "$is_macos" = false ]; then
    # Check for systemd user ssh-agent socket
    local systemd_socket="/run/user/$(id -u)/ssh-agent.socket"

    if [ -S "$systemd_socket" ]; then
      export SSH_AUTH_SOCK="$systemd_socket"

      # Check if agent is working
      if ssh-add -l &>/dev/null || [ $? -eq 1 ]; then
        # Agent is working (exit code 0 = has keys, 1 = no keys but agent OK)
        echo "Using systemd ssh-agent at $systemd_socket"

        # Add default keys if none are loaded
        if ! ssh-add -l &>/dev/null; then
          echo "Loading SSH keys..."
          for key in ~/.ssh/id_rsa ~/.ssh/id_ed25519 ~/.ssh/id_ecdsa; do
            [ -f "$key" ] && ssh-add "$key" 2>/dev/null && echo "Added: $key"
          done
        fi

        echo "Currently loaded keys:"
        ssh-add -l
        return 0
      fi
    fi

    # Fallback to keychain if available
    if command -v keychain &>/dev/null; then
      eval "$(keychain --eval --agents ssh id_rsa 2>/dev/null)"
      echo "SSH keys loaded via keychain"
      ssh-add -l 2>/dev/null || echo "No keys loaded"
      return 0
    fi

    # Last resort: start or connect to ssh-agent manually
    if [ -z "$SSH_AUTH_SOCK" ] || ! ssh-add -l &>/dev/null; then
      # Check for existing agent
      local agent_env="$HOME/.ssh/agent.env"

      if [ -f "$agent_env" ]; then
        . "$agent_env" >/dev/null
      fi

      # Test if agent is still running
      if ! ssh-add -l &>/dev/null; then
        # Start new agent
        echo "Starting new ssh-agent..."
        ssh-agent -s | grep -v '^echo' > "$agent_env"
        . "$agent_env" >/dev/null
      fi

      # Add keys
      echo "Loading SSH keys..."
      for key in ~/.ssh/id_rsa ~/.ssh/id_ed25519 ~/.ssh/id_ecdsa; do
        [ -f "$key" ] && ssh-add "$key" 2>/dev/null && echo "Added: $key"
      done
    fi

    echo "Currently loaded keys:"
    ssh-add -l
    return 0
  fi
}

# Source aliases
if [ -f "$HOME/.aliases" ]; then
  . "$HOME/.aliases"
fi

# Source local environment variables
if [ -f "$HOME/.env" ]; then
  . "$HOME/.env"
fi
